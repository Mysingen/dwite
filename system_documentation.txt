Squizzle is a library that takes care of interaction with a SqueezeBox of the
"classic" generation and later (i.e. SqueezeBox2 is supported; not SqueezeBox1).
Note that while Squizzle knows how to stream content to a box, it does not in
any way manage the end user's media library and it doesn't provide a host-side
UI for the user.

Squizzle is written in Python simply because it is such a lovely language. The
intent is to keep it small enough that it can serve as a reference implementation
for an alternative C implementation. A C "libbification" might be necessary to
enable embedding in other media players such as XMMS2 or iTunes. A rewrite does
not appear to be needed for performance reasons unless you expect it to run well
on a 100MHz machine of the early 90's or something like that.

Class hierarchies
=================

Device
------
The topmost container that holds all state pertaining to a physical device. Some
state is left out and must be specified in subclasses. There is, for instance, no
"display" member because some models don't have one.

Members
~~~~~~~
Tactile - Basically the remote control, but some boxes have buttons as well.

Classic(Device)
---------------
Subclass of Device that handles the "classic" model, including the "2" and "3"
models sold by SlimDevices.

Members
~~~~~~~
Display - Handles everything about the display.
MenuSystem - A tree structure to hold the navigable on-screen menu system.

Display
-------
A container class that represents the box's display. It handles all rendering,
animation and visualization effects. Some of these are computed entirely by the
host (e.g. menu content and screen savers) while others are done directly by the
box (e.g. spectrum analysis).

Members
~~~~~~~
Canvas - The drawable that is sent as a bitmap to the box.
Render - Currently active render. Uses the canvas.
Brightness - Brightness level.
Visualizer - Visualizer settings.

MenuSystem
----------
Uses a set of classes that represent various kinds of tree nodes. The topmost
tree class just contains a label (to show on screen) and a reference "upwards"
to a parent node.
Subclasses of the Tree class are used to represent file system directories, info
about media files, screen savers and all kinds of stuff. Container classes must
implement the ls() method.
Given a bunch of container and leaf nodes, the MenuSystem can browse the content
by entering & leaving containers, et.c. The currently displayed entry is tracked
with an index against the containers array of children. When a container is left,
the label of the container is searched for in the parent node to find the new
index value.
Tree nodes are expected to know which render object to use when visualizing the
node. The Classic core loop always asks for the render after updating the menu
system. That reference is then passed to the Display.

Canvas
------
Uses PIL classes to draw and manipulate bitmaps that can be sent to a box. Its
primary purpose is to transform a bitmap so that it will be shown correctly on
screeen.

Render
------
Timekeeping Canvas user. Must be subclassed. All subclasses must implement the
tick() method. tick() is called periodically while the render is active. Look at
the TextRender subclass for a reasonably simple example (it uses TTF fonts to
render strings and automatically scrolls strings that are too long to fit on the
Canvas).
